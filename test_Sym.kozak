>>>

// Змінні та арифметика
a := 10;
b := 5;
c := a + b * 2;
!("a + b*2 =", c);

// Типи даних
x := i`**("42");
y := f`**("3.14");
s := s`**(123);
flag := b`**(1);
!("Types:", x, y, s, flag);

// Логіка
if_check := O && X || O;
!("Logic check:", if_check);

// Умови
??(a > b) {
    !("a більший за b");
} ?!(a < b) {
    !("a менший за b");
} !! {
    !("a дорівнює b");
}

// Цикли
i := 0;
~`(i < 3) {
    !("While loop i:", i);
    i++;
}

~~(j := 0; j < 3; j := j + 1) {
    !("For loop j:", j);
}

// Масиви та for-each
arr := [1, 2, 3];
!("Original array:", arr);
~~ val :: arr {
    !("For-each value:", val);
}
+<(arr, 4);
!("After append:", arr);
+:(arr, 1, 99);
!("After insert:", arr);
!("Contains 2?", ?^(arr, 2));
!("Index of 99:", ?:(arr, 99));
!("Slice arr[1:3]:", [..](arr, 1, 3));
!("Length of arr:", ___(arr));
-<(arr, 1);
!("After remove index 1:", arr);
pop_val := -<!(arr);
!("Popped value:", pop_val, "Array now:", arr);
--<(arr);
!("After clear:", arr);

// Функції
$ greet(name) {
    !("Hello,", name);
    <! s`**("Done greeting");
}

res := greet("Kozak");
!("Greet returned:", res);

// Робота з файлами
=>("test.txt", "Hello Kozak!"); // <---- Here
content := =<("test.txt");
!("File content:", content);

// Введення
name := ?("Enter your name: ");
!("You entered:", name);

// Степові та унарні операції
count := 0;
count++;
count--;
!("Count after ++ and --:", count);

// Степені та корені
!("2^3 =", 2^3);
!("27 ^/ 3 =", 27 ^/ 3);

// Рандом
rand_val := randint(1, 10);
!("Random value 1-10:", rand_val);

/* Comment 
    Comment */

!("No Comment");

// OOP
@ Sobaka {
    @=(imya, vik) {
        ->.imya := imya;
        ->.vik := vik;
    }

    $ Bark() {
        !(->.imya + " woof!");
    }
}

sobaka := +@ Sobaka("Rex", 3);
sobaka.Bark();

//Словник
slovnyk := {"imya": "Bohdan", "vik": 30, "misto": "Kyiv"};
!(slovnyk["imya"]);

slovnyk["professiya"] := "Hetman";
!(slovnyk["professiya"]);

klyuchi_array := k{}(slovnyk);
!(klyuchi_array);

//Поліморфізм та наслідування
@ Parent {
    @=() {
        ->.field1 := "Parent field";
    }
    $ GetField1() {
        !("Parent method called!");
        <! ->.field1;
    }
}

@ Child : Parent {
    $ GetField2() {
        <! "Child field";
    }
}

my_object := +@ Child();
// These two lines are now simple statements that should require semicolons:
!(my_object.GetField1()); // Line 20 - Test inheritance (should print Parent method called! Parent field)
!(my_object.GetField2()); // Line 21 - Test polymorphism (should print Child field)



// Test 1
<<{
    x:= 10;
    y := 0;
    res := x/y;
    !("Res= ");
} >>(e){
    !("Error: ", e);
}

// Test 2
<<{
    arr2 := [1, 2, 3];
    !(arr[10]);
} >>(error_msg){
    !("Caught error: ", error_msg);
}

// Test 3
counter := 0;

<< {
    counter := counter + 1;
    !("In try block, counter: ", counter);
    !!>("Custom error message!");
} >>(e){
    counter := counter + 1;
    !("In catch block, counter:", counter);
    !("Error", e);
} <>{
    counter := counter + 1;
    !("In finally block, counter:", counter);
    !("This always runs!");
}
!("Final counter:", counter);

// Test 4
<< {
    !("Outer try");
    
    << {
        !("Inner try");
        !!>("Inner error");
    } >>(e) {
        !("Inner catch:", e);
        !!>("Re-throwing from inner catch");
    }
    
} >>(e) {
    !("Outer catch:", e);
}

// Test 5
$ safeDivide(a, b) {
    << {
        ??(b == 0) {
            !!>("Cannot divide by zero, kozache!");
        }
        <! a / b;
    } >>(e) {
        !("Division error:", e);
        <! 0;
    }
}

result1 := safeDivide(10, 2);
!("10 / 2 =", result1);

result2 := safeDivide(10, 0);
!("10 / 0 =", result2);

// Test 6
<< {
    content := =<("nonexistent.txt");
    !(content);
} >>(e) {
    !("File error:", e);
    !("Creating default file...");
    =>("nonexistent.txt", "Default content");
}

// Test 7
$ safeArrayAccess(arr, index) {
    << {
        <! arr[index];
    } >>(e) {
        !("Array access error:", e);
        <! -1;
    } <> {
        !("Array access attempted");
        
    }
}

my_arr := [10, 20, 30];
val1 := safeArrayAccess(my_arr, 1);
!("Value at index 1:", val1);

val2 := safeArrayAccess(my_arr, 10);
!("Value at index 10:", val2);

xy:= 2;
ab := xy -1;
!(ab);
