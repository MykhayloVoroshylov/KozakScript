>>>

// Змінні та арифметика
a := 10;
b := 5;
c := a + b * 2;
!("a + b*2 =", c);

// Типи даних
x := i`**("42");
y := f`**("3.14");
s := s`**(123);
flag := b`**(1);
!("Types:", x, y, s, flag);

// Логіка
if_check := 1! && 0! || 1!;
!("Logic check:", if_check);

// Умови
??(a > b) {
    !("a більший за b");
} ?!(a < b) {
    !("a менший за b");
} !! {
    !("a дорівнює b");
}

// Цикли
i := 0;
~`(i < 3) {
    !("While loop i:", i);
    i++;
}

~~(j := 0; j < 3; j := j + 1) {
    !("For loop j:", j);
}

// Масиви та for-each
arr := [1, 2, 3];
!("Original array:", arr);
~~ val :: arr {
    !("For-each value:", val);
}
+<(arr, 4);
!("After append:", arr);
+:(arr, 1, 99);
!("After insert:", arr);
!("Contains 2?", ?^(arr, 2));
!("Index of 99:", ?:(arr, 99));
!("Slice arr[1:3]:", [..](arr, 1, 3));
!("Length of arr:", ___(arr));
-<(arr, 1);
!("After remove index 1:", arr);
pop_val := -<!(arr);
!("Popped value:", pop_val, "Array now:", arr);
--<(arr);
!("After clear:", arr);

// Функції
$ greet(name) {
    !("Hello,", name);
    <! s`**("Done greeting");
}

res := greet("Kozak");
!("Greet returned:", res);

// Робота з файлами
=>("test.txt", "Hello Kozak!"); // <---- Here
content := =<("test.txt");
!("File content:", content);

// Введення
name := ?("Enter your name: ");
!("You entered:", name);

// Степові та унарні операції
count := 0;
count++;
count--;
!("Count after ++ and --:", count);

// Степені та корені
!("2^3 =", 2^3);
!("27 ^/ 3 =", 27 ^/ 3);

// Рандом
rand_val := randint(1, 10);
!("Random value 1-10:", rand_val);

/* Comment 
    Comment */

!("No Comment");

// OOP
@ Sobaka {
    @=(imya, vik) {
        ->.imya := imya;
        ->.vik := vik;
    }

    $ Bark() {
        !(->.imya + " woof!");
    }
}

sobaka := +@ Sobaka("Rex", 3);
sobaka.Bark();

//Словник
slovnyk := {"imya": "Bohdan", "vik": 30, "misto": "Kyiv"};
!(slovnyk["imya"]);

slovnyk["professiya"] := "Hetman";
!(slovnyk["professiya"]);

klyuchi_array := k{}(slovnyk);
!(klyuchi_array);

//Поліморфізм та наслідування
@ Parent {
    @=() {
        ->.field1 := "Parent field";
    }
    $ GetField1() {
        !("Parent method called!");
        <! ->.field1;
    }
}

@ Child : Parent {
    $ GetField2() {
        <! "Child field";
    }
}

my_object := +@ Child();
// These two lines are now simple statements that should require semicolons:
!(my_object.GetField1()); // Line 20 - Test inheritance (should print Parent method called! Parent field)
!(my_object.GetField2()); // Line 21 - Test polymorphism (should print Child field)



// Test 1
<<{
    x:= 10;
    y := 0;
    res := x/y;
    !("Res= ");
} >>(e){
    !("Error: ", e);
}

// Test 2
<<{
    arr2 := [1, 2, 3];
    !(arr[10]);
} >>(error_msg){
    !("Caught error: ", error_msg);
}

// Test 3
counter := 0;

<< {
    counter := counter + 1;
    !("In try block, counter: ", counter);
    !!>("Custom error message!");
} >>(e){
    counter := counter + 1;
    !("In catch block, counter:", counter);
    !("Error", e);
} <>{
    counter := counter + 1;
    !("In finally block, counter:", counter);
    !("This always runs!");
}
!("Final counter:", counter);

// Test 4
<< {
    !("Outer try");
    
    << {
        !("Inner try");
        !!>("Inner error");
    } >>(e) {
        !("Inner catch:", e);
        !!>("Re-throwing from inner catch");
    }
    
} >>(e) {
    !("Outer catch:", e);
}

// Test 5
$ safeDivide(a, b) {
    << {
        ??(b == 0) {
            !!>("Cannot divide by zero, kozache!");
        }
        <! a / b;
    } >>(e) {
        !("Division error:", e);
        <! 0;
    }
}

result1 := safeDivide(10, 2);
!("10 / 2 =", result1);

result2 := safeDivide(10, 0);
!("10 / 0 =", result2);

// Test 6
<< {
    content := =<("nonexistent.txt");
    !(content);
} >>(e) {
    !("File error:", e);
    !("Creating default file...");
    =>("nonexistent.txt", "Default content");
}

// Test 7
$ safeArrayAccess(arr, index) {
    << {
        <! arr[index];
    } >>(e) {
        !("Array access error:", e);
        <! -1;
    } <> {
        !("Array access attempted");
        
    }
}

my_arr := [10, 20, 30];
val1 := safeArrayAccess(my_arr, 1);
!("Value at index 1:", val1);

val2 := safeArrayAccess(my_arr, 10);
!("Value at index 10:", val2);

xy:= 2;
ab := xy -1;
!(ab);

arr23 := [[1,2,3],[4,5,6]];
!(arr23[1][2]);

arr23[0][0] := 100;
!("Modified Matrix: ", arr23);

mat := @[](4,5,0);
!("Empty matrix: ", mat);

~~ (i:= 0; i < 4; i++){
    ~~ (j:= 0; j<5; j++){
        mat[i][j] := i*5+j;
    }
}
!("Filled matrix: ", mat);

size := #[](mat);
!("Rows:", size[0], "Cols:", size[1]);

// Get a specific row
row := []->(mat, 2);
!("Row 2:", row);

// Get a specific column
col := []|(mat, 3);
!("Column 3:", col);

// Transpose the matrix
transposed := []^(mat);
!("Transposed:", transposed);

board := @[](3, 3, "-");

$ print_board() {
    ~~ (i := 0; i < 3; i++) {
        !(board[i][0], board[i][1], board[i][2]);
    }
}

$ make_move(row, col, player) {
    ?? (row >= 0 && row < 3 && col >= 0 && col < 3) {
        ?? (board[row][col] == "-") {
            board[row][col] := player;
            <! Pravda;
        }
    }
    <! Nepravda;
}

// Play some moves
make_move(0, 0, "X");
make_move(1, 1, "O");
make_move(0, 1, "X");
make_move(2, 2, "O");

print_board();

// Create a 3D array (e.g., 2x3x4 cube)
cube := [
    [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]],
    [[13, 14, 15, 16], [17, 18, 19, 20], [21, 22, 23, 24]]
];

// Access 3D element
value := cube[1][2][3];  // Gets 24
!("Element at [1][2][3]:", value);

// Flatten the entire structure
flat := []>(cube);
!("Flattened:", flat);

$ matrix_add(a, b) {
    rows := #[](a)[0];
    cols := #[](a)[1];
    result := @[](rows, cols, 0);
    
    ~~ (i := 0; i < rows; i++) {
        ~~ (j := 0; j < cols; j++) {
            result[i][j] := a[i][j] + b[i][j];
        }
    }
    
    <! result;
}

$ matrix_multiply_scalar(mat, scalar) {
    rows := #[](mat)[0];
    cols := #[](mat)[1];
    result := @[](rows, cols, 0);
    
    ~~ (i := 0; i < rows; i++) {
        ~~ (j := 0; j < cols; j++) {
            result[i][j] := mat[i][j] * scalar;
        }
    }
    
    <! result;
}

m1 := [[1, 2], [3, 4]];
m2 := [[5, 6], [7, 8]];

sum := matrix_add(m1, m2);
!("Sum:", sum);

doubled := matrix_multiply_scalar(m1, 2);
!("Doubled:", doubled);


